<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · ParametricOptInterface.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ParametricOptInterface.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#MOI-example-1"><span>MOI example</span></a></li><li><a class="tocitem" href="#JuMP-Example-1"><span>JuMP Example</span></a></li></ul></li><li><a class="tocitem" href="../reference/">-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/ParametricOptInterface.jl/blob/master/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h1><h2 id="MOI-example-1"><a class="docs-heading-anchor" href="#MOI-example-1">MOI example</a><a class="docs-heading-anchor-permalink" href="#MOI-example-1" title="Permalink"></a></h2><p>Lets write a setep-by-step example of <code>POI</code> usage at the MOI level.</p><p>First, we declare a <code>Optimizer</code> on top of a <code>MOI</code> optimizer. In the example, we consider <code>HiGHS</code> as the underlying solver:</p><pre><code class="language-julia">using HiGHS
using MathOptInterface
using ParametricOptInterface

const MOI = MathOptInterface
const POI = ParametricOptInterface

optimizer = POI.Optimizer(HiGHS.Optimizer())</code></pre><p>Then, we declare the constants that will be used in this model, for ease of reference:</p><pre><code class="language-julia">c = [4.0, 3.0]
A1 = [2.0, 1.0, 3.0]
A2 = [1.0, 2.0, 0.5]
b1 = 4.0
b2 = 4.0</code></pre><p>We declare the variable <code>x</code> as in a typical <code>MOI</code> model, and we add a non-negativity constraint:</p><pre><code class="language-julia">x = MOI.add_variables(optimizer, length(c))

for x_i in x
            MOI.add_constraint(optimizer, x_i, MOI.GreaterThan(0.0))
        end</code></pre><p>Now, let&#39;s consider 3 parameters. Two of them, <code>y</code>, <code>z</code>, will be placed in the constraints and one, <code>w</code>, in the objective function. We&#39;ll start all three of them with a value equal to <code>0</code>:</p><pre><code class="language-julia">w, cw = MOI.add_constrained_variable(optimizer, POI.Parameter(0))
y, cy = MOI.add_constrained_variable(optimizer, POI.Parameter(0))
z, cz = MOI.add_constrained_variable(optimizer, POI.Parameter(0))</code></pre><p>Now, let&#39;s add the constraints. Notice that we treat parameters and variables in the same way when building the functions that will be placed in some set to create a constraint (<code>Function-in-Set</code>):</p><pre><code class="language-julia">cons1 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A1, [x[1], x[2], y]), 0.0)
ci1 = MOI.add_constraint(optimizer, cons1, MOI.LessThan(b1))</code></pre><pre><code class="language-julia">cons2 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A2, [x[1], x[2], z]), 0.0)
ci2 = MOI.add_constraint(optimizer, cons2, MOI.LessThan(b2))</code></pre><p>Finally, we declare and add the objective function, with its respective sense:</p><pre><code class="language-julia">obj_func = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([c[1], c[2], 2.0], [x[1], x[2], w]), 0.0)
MOI.set(optimizer, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(), obj_func)
MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)</code></pre><p>Now we can optimize the model and assess its termination and primal status:</p><pre><code class="language-julia">MOI.optimize!(optimizer)
MOI.get(optimizer, MOI.TerminationStatus())
MOI.get(optimizer, MOI.PrimalStatus())</code></pre><p>Given the optimized solution, we check that its value is, as expected, equal to <code>28/3</code>, and the solution vector <code>x</code> is <code>[4/3, 4/3]</code>:</p><pre><code class="language-julia">isapprox(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)
isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)
isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)</code></pre><p>We can also retrieve the dual values associated to each parameter, <strong>as they are all additive</strong>:</p><pre><code class="language-julia">MOI.get(optimizer, MOI.ConstraintDual(), cy)
MOI.get(optimizer, MOI.ConstraintDual(), cz)
MOI.get(optimizer, MOI.ConstraintDual(), cw)</code></pre><p>Notice the direct relationship in this case between the parameters&#39; duals and the associated constraints&#39; duals. The  <code>y</code> parameter, for example, only appears in the <code>cons1</code>. If we compare their duals, we can check that the dual of <code>y</code> is equal to its coefficient in <code>cons1</code> multiplied by the constraint&#39;s dual itself, as expected:</p><pre><code class="language-julia">isapprox(MOI.get(optimizer, MOI.ConstraintDual(), cy), 3*MOI.get(optimizer, MOI.ConstraintDual(), ci1), atol = 1e-4)</code></pre><p>The same is valid for the remaining parameters. In case a parameter appears in more than one constraint, or both some constraints and in the objective function, its dual will be equal to the linear combination of the functions&#39; duals multiplied by the respective coefficientes.</p><p>So far, we only added some parameters that had no influence at first in solving the model. Let&#39;s change the values associated to each parameter to assess its implications. First, we set the value of parameters <code>y</code> and <code>z</code> to <code>1.0</code>. Notice that we are changing the feasible set of the decision variables:</p><pre><code class="language-julia">MOI.set(optimizer, MOI.ConstraintSet(), cy, POI.Parameter(1.0))
MOI.set(optimizer, MOI.ConstraintSet(), cz, POI.Parameter(1.0))</code></pre><p>However, if we check the optimized model now, there will be no changes in the objective function value or the in the optimized decision variables:</p><pre><code class="language-julia">isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)
isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)
isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)</code></pre><p>Although we changed the parameter values, we didn&#39;t optimize the model yet. Thus, <strong>to apply the parameters&#39; changes, the model must be optimized again</strong>:</p><pre><code class="language-julia">MOI.optimize!(optimizer)</code></pre><p>The <code>MOI.optimize!()</code> function handles the necessary updates, properly fowarding the new outer model (<code>POI</code> model) additions to the inner model (<code>MOI</code> model) which will be handled by the solver. Now we can assess the updated optimized information:</p><pre><code class="language-julia">isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 3.0, atol = 1e-4)
MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]</code></pre><p>If we update the parameter <code>w</code>, associated to the objective function, we are simply adding a constant to it. Notice how the new objective function is precisely equal to the previous one plus the new value of <code>w</code>. In addition, as we didn&#39;t update the feasible set, the optimized decision variables remain the same.</p><pre><code class="language-julia">MOI.set(optimizer, MOI.ConstraintSet(), cw, POI.Parameter(2.0))
# Once again, the model must be optimized to incorporate the changes
MOI.optimize!(optimizer)
# Only the objective function value changes
isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 7.0, atol = 1e-4)
MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]</code></pre><h2 id="JuMP-Example-1"><a class="docs-heading-anchor" href="#JuMP-Example-1">JuMP Example</a><a class="docs-heading-anchor-permalink" href="#JuMP-Example-1" title="Permalink"></a></h2><p>Lets write a setep-by-step example of <code>POI</code> usage at the JuMP level.</p><p>First, we declare a <code>Model</code> on top of a <code>Optimizer</code> of an underlying solver. In the example, we consider <code>HiGHS</code> as the underlying solver:</p><pre><code class="language-julia">using HiGHS
using JuMP

using ParametricOptInterface
const POI = ParametricOptInterface

model = Model(() -&gt; ParametricOptInterface.Optimizer(HiGHS.Optimizer()))</code></pre><p>We declare the variable <code>x</code> as in a typical <code>JuMP</code> model:</p><pre><code class="language-julia">@variable(model, x[i = 1:2] &gt;= 0)</code></pre><p>Now, let&#39;s consider 3 parameters. Two of them, <code>y</code>, <code>z</code>, will be placed in the constraints and one, <code>w</code>, in the objective function. We&#39;ll start all three of them with a value equal to <code>0</code>:</p><pre><code class="language-julia">@variable(model, y in ParametricOptInterface.Parameter(0))
@variable(model, z in ParametricOptInterface.Parameter(0))
@variable(model, w in ParametricOptInterface.Parameter(0))</code></pre><p>let&#39;s add the constraints. Notice that we treat parameters the same way we treat variables when writing the model:</p><pre><code class="language-julia">@constraint(model, c1, 2x[1] + x[2] + 3y &lt;= 4)
@constraint(model, c2, x[1] + 2x[2] + 0.5z &lt;= 4)</code></pre><p>Finally, we declare and add the objective function, with its respective sense:</p><pre><code class="language-julia">@objective(model, Max, 4x[1] + 3x[2] + 2w)</code></pre><p>We can optimize the model and assess its termination and primal status:</p><pre><code class="language-julia">optimize!(model)
termination_status(model)
primal_status(model)</code></pre><p>Given the optimized solution, we check that its value is, as expected, equal to <code>28/3</code>, and the solution vector <code>x</code> is <code>[4/3, 4/3]</code>:</p><pre><code class="language-julia">isapprox(objective_value(model), 28/3)
isapprox(value.(x), [4/3, 4/3])</code></pre><p>We can also retrieve the dual values associated to each parameter, <strong>as they are all additive</strong>:</p><pre><code class="language-julia">MOI.get(model, POI.ParameterDual(), y)
MOI.get(model, POI.ParameterDual(), z)
MOI.get(model, POI.ParameterDual(), w)</code></pre><p>Notice the direct relationship in this case between the parameters&#39; duals and the associated constraints&#39; duals. The <code>y</code> parameter, for example, only appears in the <code>c1</code>. If we compare their duals, we can check that the dual of <code>y</code> is equal to its coefficient in <code>c1</code> multiplied by the constraint&#39;s dual itself, as expected:</p><pre><code class="language-julia">dual_of_y = MOI.get(model, POI.ParameterDual(), y)
isapprox(dual_of_y, 3 * dual(c1))</code></pre><p>The same is valid for the remaining parameters. In case a parameter appears in more than one constraint, or both some constraints and in the objective function, its dual will be equal to the linear combination of the functions&#39; duals multiplied by the respective coefficientes.</p><p>So far, we only added some parameters that had no influence at first in solving the model. Let&#39;s change the values associated to each parameter to assess its implications. First, we set the value of parameters <code>y</code> and <code>z</code> to <code>1.0</code>. Notice that we are changing the feasible set of the decision variables:</p><pre><code class="language-julia">MOI.set(model, POI.ParameterValue(), y, 1)
MOI.set(model, POI.ParameterValue(), z, 1)</code></pre><p>To apply the parameters&#39; changes, the model must be optimized again:</p><pre><code class="language-julia">optimize!(model)</code></pre><p>The <code>optimize!</code> function handles the necessary updates, properly fowarding the new outer model (<code>POI</code> model) additions to the inner model (<code>MOI</code> model) which will be handled by the solver. Now we can assess the updated optimized information:</p><pre><code class="language-julia">isapprox(objective_value(model), 3)
isapprox(value.(x), [0, 1])</code></pre><p>If we update the parameter <code>w</code>, associated to the objective function, we are simply adding a constant to it. Notice how the new objective function is precisely equal to the previous one plus the new value of <code>w</code>. In addition, as we didn&#39;t update the feasible set, the optimized decision variables remain the same.</p><pre><code class="language-julia">MOI.set(model, POI.ParameterValue(), w, 2)
# Once again, the model must be optimized to incorporate the changes
optimize!(model)
# Only the objective function value changes
isapprox(objective_value(model), 7)
isapprox(value.(x), [0, 1])</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Manual</a><a class="docs-footer-nextpage" href="../reference/">- »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 25 April 2022 17:17">Monday 25 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
