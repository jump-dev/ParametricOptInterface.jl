var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Why-use-parameters?-1","page":"Manual","title":"Why use parameters?","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A typical optimization model built using MathOptInterface.jl (MOIfor short) has two main components:     1. Variables     2. Constants","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Using these basic elements, one can create functions and sets that, together, form the desired optimization model. THE GOAL OF POI is the implementation of a third type, parameters, which     * are declared similar to a variable, and inherits some functionalities (e.g. dual calculation)     * acts like a constant, in the sense that it has a fixed value that will remain the same unless explicitely changed by the user","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A main concern is to efficiently implement this new type, as one typical usage is to change its value to analyze the model behavior, without the need to build a new one from scratch.","category":"page"},{"location":"manual/#How-it-works-1","page":"Manual","title":"How it works","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The main idea applied in POI is that the interaction between the solver, e.g. GLPK, and the optimization model will be handled by MOI as usual. Because of that, POI is a higher level wrapper around MOI, responsible for receiving variables, constants and parameters, and forwarding to the lower level model only variables and constants.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"As POI receives parameters, it must analyze and decide how they should be handled on the lower level optimization model (the MOI model).","category":"page"},{"location":"manual/#Usage-1","page":"Manual","title":"Usage","text":"","category":"section"},{"location":"manual/#Supported-constraints-1","page":"Manual","title":"Supported constraints","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This is a list of supported MOI constraint functions that can handle parameters. If you try to add a parameter to  a function that is not listed here, it will return an unsupported error.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"MOI Function\nScalarAffineFunction\nScalarQuadraticFunction","category":"page"},{"location":"manual/#Supported-objective-functions-1","page":"Manual","title":"Supported objective functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"MOI Function\nScalarAffineFunction\nScalarQuadraticFunction","category":"page"},{"location":"manual/#Declare-a-ParametricOptimizer-1","page":"Manual","title":"Declare a ParametricOptimizer","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In order to use parameters, the user needs to declare a ParametricOptimizer on top of a MOI optimizer, such as GLPK.Optimizer().","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using ParametricOptInterface, MathOptInterface, GLPK\n# Rename ParametricOptInterface and MathOptInterface to simplify the code\nconst POI = ParametricOptInterface\nconst MOI = MathOptInterface\n# Define a ParametricOptimizer on top of the MOI optimizer\noptimizer = POI.ParametricOptimizer(GLPK.Optimizer())","category":"page"},{"location":"manual/#Parameters-1","page":"Manual","title":"Parameters","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A Parameter is a variable with a fixed value that can be changed by the user.","category":"page"},{"location":"manual/#Adding-a-new-parameter-to-a-model-1","page":"Manual","title":"Adding a new parameter to a model","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"To add a parameter to a model, we must use the MOI.add_constrained_variable() function, passing as its arguments the model and a Parameter with its given value:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"y, cy = MOI.add_constrained_variable(optimizer, POI.Parameter(0))","category":"page"},{"location":"manual/#Changing-the-parameter-value-1","page":"Manual","title":"Changing the parameter value","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"To change a given parameter's value, access its ConstraintIndex and set it to the new value using the Parameter structure.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"MOI.set(optimizer, MOI.ConstraintSet(), cy, POI.Parameter(2.0))","category":"page"},{"location":"manual/#Retrieving-the-dual-of-a-parameter-1","page":"Manual","title":"Retrieving the dual of a parameter","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Given an optimized model, one can calculate the dual associated to a parameters, as long as it is an additive term in the constraints or objective. One can do so by getting the MOI.ConstraintDual attribute of the paraameter's MOI.ConstraintIndex:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"MOI.get(optimizer, MOI.ConstraintDual, cy)","category":"page"},{"location":"#ParametricOptInterface.jl-Documentation-1","page":"Home","title":"ParametricOptInterface.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ParametricOptInterface.jl (POI for short) is a package written on top of MathOptInterface.jl that allows users to add parameters to a MOI/JuMP problem explicitely.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install the package you can use Pkg.add it as follows:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add ParametricOptInterface","category":"page"},{"location":"#Contributing-1","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When contributing please note that the package follows the JuMP style guide","category":"page"},{"location":"example/#Example-1","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#","page":"Example","title":"Example","text":"Lets write a setep-by-step example of POI usage. ","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"First, we declare a ParametricOptimizer on top of a MOI optimizer. In the example, we consider GLPK as the underlying solver:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> optimizer = POI.ParametricOptimizer(GLPK.Optimizer())","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Then, we declare the constants that will be used in this model, for ease of reference:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> c = [4.0, 3.0]\njulia> A1 = [2.0, 1.0, 3.0]\njulia> A2 = [1.0, 2.0, 0.5]\njulia> b1 = 4.0\njulia> b2 = 4.0","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"We declare the variable x as in a typical MOI model, and we add a non-negativity constraint:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> x = MOI.add_variables(optimizer, length(c))\n\njulia> for x_i in x\n            MOI.add_constraint(optimizer, MOI.SingleVariable(x_i), MOI.GreaterThan(0.0))\n        end","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Now, let's consider 3 parameters. Two of them, y, z, will be placed in the constraints and one, w, in the objective function. We'll start all three of them with a value equal to 0:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> w, cw = MOI.add_constrained_variable(optimizer, POI.Parameter(0))\njulia> y, cy = MOI.add_constrained_variable(optimizer, POI.Parameter(0))\njulia> z, cz = MOI.add_constrained_variable(optimizer, POI.Parameter(0))","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Now, let's add the constraints. Notice that we treat parameters and variables in the same way when building the functions that will be placed in some set to create a constraint (Function-in-Set):","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> cons1 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A1, [x[1], x[2], y]), 0.0)\njulia> ci1 = MOI.add_constraint(optimizer, cons1, MOI.LessThan(b1))","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> cons2 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(A2, [x[1], x[2], z]), 0.0)\njulia> ci2 = MOI.add_constraint(optimizer, cons2, MOI.LessThan(b2))","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Finally, we declare and add the objective function, with its respective sense:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> obj_func = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([c[1], c[2], 2.0], [x[1], x[2], w]), 0.0)\njulia> MOI.set(optimizer, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(), obj_func)\njulia> MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Now we can optimize the model and assess its termination and primal status:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> MOI.optimize!(optimizer)\njulia> MOI.get(optimizer, MOI.TerminationStatus())\njulia> MOI.get(optimizer, MOI.PrimalStatus())","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Given the optimized solution, we check that its value is, as expected, equal to 28/3, and the solution vector x is [4/3, 4/3]:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> isapprox(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)\njulia> isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)\njulia> isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"We can also retrieve the dual values associated to each parameter, as they are all additive:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> MOI.get(optimizer, MOI.ConstraintDual(), cy)\njulia> MOI.get(optimizer, MOI.ConstraintDual(), cz)\njulia> MOI.get(optimizer, MOI.ConstraintDual(), cw)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Notice the direct relationship in this case between the parameters' duals and the associated constraints' duals. The  y parameter, for example, only appears in the cons1. If we compare their duals, we can check that the dual of y is equal to its coefficient in cons1 multiplied by the constraint's dual itself, as expected:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> isapprox(MOI.get(optimizer, MOI.ConstraintDual(), cy), 3*MOI.get(optimizer, MOI.ConstraintDual(), ci1), atol = 1e-4)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"The same is valid for the remaining parameters. In case a parameter appears in more than one constraint, or both some constraints and in the objective function, its dual will be equal to the linear combination of the functions' duals multiplied by the respective coefficientes.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"So far, we only added some parameters that had no influence at first in solving the model. Let's change the values associated to each parameter to assess its implications. First, we set the value of parameters y and z to 1.0. Notice that we are changing the feasible set of the decision variables:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> MOI.set(optimizer, MOI.ConstraintSet(), cy, POI.Parameter(1.0))\njulia> MOI.set(optimizer, MOI.ConstraintSet(), cz, POI.Parameter(1.0))","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"However, if we check the optimized model now, there will be no changes in the objective function value or the in the optimized decision variables:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)\njulia> isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)\njulia> isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"Although we changed the parameter values, we didn't optimize the model yet. Thus, to apply the parameters' changes, the model must be optimized again:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> MOI.optimize!(optimizer)","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"The MOI.optimize!() function handles the necessary updates, properly fowarding the new outer model (POI model) additions to the inner model (MOI model) which will be handled by the solver. Now we can assess the updated optimized information:","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> @test isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 3.0, atol = 1e-4)\njulia> @test MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"If we update the parameter w, associated to the objective function, we are simply adding a constant to it. Notice how the new objective function is precisely equal to the previous one plus the new value of w. In addition, as we didn't update the feasible set, the optimized decision variables remain the same.","category":"page"},{"location":"example/#","page":"Example","title":"Example","text":"julia> MOI.set(optimizer, MOI.ConstraintSet(), cw, POI.Parameter(2.0))\n# Once again, the model must be optimized to incorporate the changes\njulia> MOI.optimize!(optimizer)\n# Only the objective function value changes\njulia> @test isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 7.0, atol = 1e-4)\njulia> @test MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]","category":"page"}]
}
