var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"This page lists the public API of ParametericOptInterface.\n\nLoad the module with:\n\nimport ParametericOptInterface as POI\n\nand then prefix all calls with POI. to create POI.<NAME>.","category":"section"},{"location":"reference/#Optimizer","page":"Reference","title":"Optimizer","text":"","category":"section"},{"location":"reference/#ConstraintsInterpretation","page":"Reference","title":"ConstraintsInterpretation","text":"","category":"section"},{"location":"reference/#ParametricOptInterface.Optimizer","page":"Reference","title":"ParametricOptInterface.Optimizer","text":"Optimizer{T}(\n    optimizer::Union{MOI.ModelLike,Any};\n    evaluate_duals::Bool = true,\n    save_original_objective_and_constraints::Bool = true,\n    with_bridge_type = nothing,\n)\n\nCreate an Optimizer, which allows the handling of parameters in an optimization model.\n\nIf optimizer is not a MOI.ModelLike, the inner optimizer is constructed using MOI.instantiate(optimizer; with_bridge_type).\n\nThe {T} type parameter is optional; it defaults to Float64.\n\nKeyword arguments\n\nevaluate_duals::Bool: If true, evaluates the dual of parameters. Set it to false to increase performance when the duals of parameters are not necessary. Defaults to true.\nsave_original_objective_and_constraints: If true saves the orginal function and set of the constraints as well as the original objective function inside Optimizer. This is useful for printing the model but greatly increases the memory footprint. Users might want to set it to false to increase performance in applications where you don't need to query the original expressions provided to the model in constraints or in the objective. Note that this might break printing or queries such as MOI.get(model, MOI.ConstraintFunction(), c). Defaults to true.\nwith_bridge_type: this is ignroed if optimizer::MOI.ModelLike, otherwise it is passed to MOI.instantiate.\n\nExample\n\njulia> import ParametricOptInterface as POI\n\njulia> import HiGHS\n\njulia> POI.Optimizer(HiGHS.Optimizer(); evaluate_duals = true)\nParametricOptInterface.Optimizer{Float64, HiGHS.Optimizer}\n├ ObjectiveSense: FEASIBILITY_SENSE\n├ ObjectiveFunctionType: MOI.ScalarAffineFunction{Float64}\n├ NumberOfVariables: 0\n└ NumberOfConstraints: 0\n\njulia> POI.Optimizer(\n           HiGHS.Optimizer;\n           with_bridge_type = Float64,\n           evaluate_duals = false,\n       )\nParametricOptInterface.Optimizer{Float64, MOIB.LazyBridgeOptimizer{HiGHS.Optimizer}}\n├ ObjectiveSense: FEASIBILITY_SENSE\n├ ObjectiveFunctionType: MOI.ScalarAffineFunction{Float64}\n├ NumberOfVariables: 0\n└ NumberOfConstraints: 0\n\n\n\n\n\n","category":"type"},{"location":"reference/#ParametricOptInterface.ConstraintsInterpretation","page":"Reference","title":"ParametricOptInterface.ConstraintsInterpretation","text":"ConstraintsInterpretation <: MOI.AbstractOptimizerAttribute\n\nAttribute to define how Optimizer should interpret constraints.\n\nPOI.ONLY_CONSTRAINTS: always interpret ScalarAffineFunction constraints as linear constraints. If an expression such as x >= p1 + p2 appears, it will be treated like an affine constraint. This is the default behaviour of Optimizer\nPOI.ONLY_BOUNDS: always interpret ScalarAffineFunction constraints as a variable bound. This is valid for constraints such as x >= p or x >= p1 + p2. If a constraint x1 + x2 >= p appears which is not a valid variable bound, an error will be thrown.\nPOI.BOUNDS_AND_CONSTRAINTS: interpret ScalarAffineFunction constraints as a variable bound if they are a valid variable bound, for example, x >= p or x >= p1 + p2, and interpret them as linear constraints otherwise.\n\nExample\n\njulia> import MathOptInterface as MOI\n\njulia> import ParametricOptInterface as POI\n\njulia> model = POI.Optimizer(MOI.Utilities.Model{Float64}())\nParametricOptInterface.Optimizer{Float64, MOIU.Model{Float64}}\n├ ObjectiveSense: FEASIBILITY_SENSE\n├ ObjectiveFunctionType: MOI.ScalarAffineFunction{Float64}\n├ NumberOfVariables: 0\n└ NumberOfConstraints: 0\n\njulia> MOI.set(model, POI.ConstraintsInterpretation(), POI.ONLY_BOUNDS)\nONLY_BOUNDS::ConstraintsInterpretationCode = 1\n\njulia> MOI.set(model, POI.ConstraintsInterpretation(), POI.ONLY_CONSTRAINTS)\nONLY_CONSTRAINTS::ConstraintsInterpretationCode = 0\n\njulia> MOI.set(model, POI.ConstraintsInterpretation(), POI.BOUNDS_AND_CONSTRAINTS)\nBOUNDS_AND_CONSTRAINTS::ConstraintsInterpretationCode = 2\n\n\n\n\n\n","category":"type"},{"location":"#ParametricOptInterface.jl","page":"Home","title":"ParametricOptInterface.jl","text":"ParametricOptInterface.jl is a package that adds parameters to models in JuMP and MathOptInterface.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"ParametricOptInterface.jl is licensed under the MIT License.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install ParametricOptInterface using Pkg.add:\n\nimport Pkg\nPkg.add(\"ParametricOptInterface\")","category":"section"},{"location":"#Use-with-JuMP","page":"Home","title":"Use with JuMP","text":"Use ParametricOptInterface with JuMP by following this brief example:\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()))\n@variable(model, x)\n@variable(model, p in Parameter(1))\n@constraint(model, p * x + p >= 3)\n@objective(model, Min, 2x + p)\noptimize!(model)\nvalue(x)\nset_parameter_value(p, 2.0)\noptimize!(model)\nvalue(x)","category":"section"},{"location":"#How-and-why-ParametricOptInterface-is-needed","page":"Home","title":"How and why ParametricOptInterface is needed","text":"JuMP and MathOptInterface have support for parameters. Parameters are decision variables that belong to the Parameter set. The Parameter set is conceptually similar to the EqualTo set, except that solvers may treat a decision variable constrained to the Parameter set as a constant, and they need not add it as a decision variable to the model.\n\nIn JuMP, a parameter can be added using the following syntax:\n\nusing JuMP\nmodel = Model();\n@variable(model, p in Parameter(2))\nparameter_value(p)\nset_parameter_value(p, 3.0)\nparameter_value(p)\n\nIn MathOptInterface, a parameter can be added using the following syntax:\n\nimport MathOptInterface as MOI\nmodel = MOI.Utilities.Model{Float64}();\np, p_con = MOI.add_constrained_variable(model, MOI.Parameter(2.0))\nMOI.get(model, MOI.ConstraintSet(), p_con)\nnew_set = MOI.Parameter(3.0)\nMOI.set(model, MOI.ConstraintSet(), p_con, new_set)\nMOI.get(model, MOI.ConstraintSet(), p_con)","category":"section"},{"location":"#Some-solvers-have-native-support-for-parameters","page":"Home","title":"Some solvers have native support for parameters","text":"Some solvers have native support for parameters. example is Ipopt. To demonstrate, look at the following example. Even though there are two @variable calls, the log of Ipopt shows that it solved a problem with only one decision variable:\n\nusing JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, x)\n@variable(model, p in Parameter(1))\n@constraint(model, x + p >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\n\nInternally, Ipopt replaced the parameter p with the constant 1.0, and solved the problem:\n\nusing JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, x)\n@constraint(model, x + 1 >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\n\nParameters are most useful when you want to solve a sequence of problems in which some of the data changes between iterations:\n\nusing JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x)\n@variable(model, p in Parameter(1))\n@constraint(model, x + p >= 3)\n@objective(model, Min, 2x)\nsolution = Dict{Int,Float64}()\nfor p_value in 0:5\n    set_parameter_value(p, p_value)\n    optimize!(model)\n    assert_is_solved_and_feasible(model)\n    solution[p_value] = value(x)\nend\nsolution","category":"section"},{"location":"#Some-solvers-do-not-have-native-support-for-parameters","page":"Home","title":"Some solvers do not have native support for parameters","text":"Even though solvers like Ipopt support parameters, many solvers do not. One example is HiGHS. Despite the fact that HiGHS doesn't support parameters, you can still build and solve a model with parameters:\n\nusing JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x)\n@variable(model, p in Parameter(1))\n@constraint(model, x + p >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\n\nThis works because, behind the scenes, the bridges in MathOptInterface rewrote p in Parameter(1) to p in MOI.EqualTo(1.0):\n\nprint_active_bridges(model)\n\nThus, HiGHS solved the problem:\n\nusing JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer)\n@variable(model, x)\n@variable(model, p == 1)\n@constraint(model, x + p >= 3)\n@objective(model, Min, 2x)\noptimize!(model)\n\nThe downside to the bridge approach is that it adds a new decision variable with fixed bounds for every parameter in the problem. Moreover, the bridge approach does not handle parameter * variable terms, because the resulting problem is a quadratic constraint:\n\njulia> using JuMP, HiGHS\n\njulia> model = Model(HiGHS.Optimizer);\n\njulia> @variable(model, x);\n\njulia> @variable(model, p in Parameter(1));\n\njulia> @constraint(model, p * x >= 3)\nERROR: Constraints of type MathOptInterface.ScalarQuadraticFunction{Float64}-in-MathOptInterface.GreaterThan{Float64} are not supported by the solver.\n\nIf you expected the solver to support your problem, you may have an error in your formulation. Otherwise, consider using a different solver.\n\nThe list of available solvers, along with the problem types they support, is available at https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers.\nStacktrace:\n[...]","category":"section"},{"location":"#ParametricOptInterface","page":"Home","title":"ParametricOptInterface","text":"ParametricOptInterface provides Optimizer, which is a meta-optimizer that wraps another optimizer. Instead of adding fixed variables to the model, POI substitutes out the parameters with their value before passing the constraint or objective to the inner optimizer. When the parameter value is changed, POI efficiently modifies the inner optimizer to reflect the new parameter values.\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()));\n@variable(model, x);\n@variable(model, p in Parameter(1));\n@constraint(model, x + p >= 3);\n@objective(model, Min, 2x);\noptimize!(model)\n\nNote how HiGHS now solves a problem with one decision variable.\n\nBecause POI replaces parameters with their constant value, POI supports parameter * variable terms:\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()));\n@variable(model, x);\n@variable(model, p in Parameter(1));\n@constraint(model, p * x >= 3)\n@objective(model, Min, 2x)\noptimize!(model)","category":"section"},{"location":"#When-to-use-ParametricOptInterface","page":"Home","title":"When to use ParametricOptInterface","text":"You should use ParametricOptInterface when:\n\nyou are using a solver that does not have native support for parameters\nyou are solving a single problem for multiple values of the parameters.\n\nFor problems with a small number of parameters, and in which the parameters appear additively in the constraints and the objective, it may be more efficient to use the bridge approach. In general, you should try with and without POI and choose the approach which works best for your model.","category":"section"},{"location":"#The-dual-of-a-parameter","page":"Home","title":"The dual of a parameter","text":"In some applications you may need the dual of a parameter. The dual can be computed only if the parameter appears additively in the problem. Query the dual associated with the parameter as follows:\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()));\nset_silent(model)\n@variable(model, x);\n@variable(model, p in Parameter(1));\n@constraint(model, x + p >= 3);\n@objective(model, Min, 2x);\noptimize!(model)\ndual(VariableInSetRef(p))\n\nNote how the dual is the same as the reduced_cost of an equivalent fixed variable:\n\nusing JuMP, HiGHS\nmodel = Model(HiGHS.Optimizer);\nset_silent(model)\n@variable(model, x);\n@variable(model, p == 1);\n@constraint(model, x + p >= 3);\n@objective(model, Min, 2x);\noptimize!(model)\nreduced_cost(p)","category":"section"},{"location":"#Variable-bounds","page":"Home","title":"Variable bounds","text":"An ambiguity arises when the user writes a model like:\n\nusing JuMP\nmodel = Model();\n@variable(model, x)\n@variable(model, p in Parameter(2))\n@constraint(model, x >= p)\n\nDid they mean an affine constraint like 1.0 * x + 0.0 in GreaterThan(2.0), or did they mean a variable bound like x in GreaterThan(2.0)?\n\nBy default, ParametricOptInterface does not attempt to simplify affine constraints involving parameters to variable bounds, but this behavior can be controlled using the ConstraintsInterpretation attribute.\n\nFor example, the default is:\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()));\nset_attribute(model, POI.ConstraintsInterpretation(), POI.ONLY_CONSTRAINTS)\n@variable(model, x);\n@variable(model, p in Parameter(1));\n@constraint(model, x >= p)\noptimize!(model)\n\nbut by setting the ConstraintsInterpretation attribute to POI.BOUNDS_AND_CONSTRAINTS, we can solve a problem with one decision variable and zero constraint rows:\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()));\nset_attribute(model, POI.ConstraintsInterpretation(), POI.BOUNDS_AND_CONSTRAINTS)\n@variable(model, x);\n@variable(model, p in Parameter(1));\n@constraint(model, x >= p)\noptimize!(model)","category":"section"},{"location":"#Parameters-multiplying-quadratic-terms","page":"Home","title":"Parameters multiplying quadratic terms","text":"POI supports parameters that multiply quadratic variable terms in objectives only. This creates cubic polynomial expressions of the form c * p * x * y where c is a number, p is a parameter, and x and y are variables. After parameter substitution, the objective is quadratic instead of cubic.\n\nNote that the maximum degree is 3 (cubic), at least one factor in each cubic term must be a parameter, and pure cubic variable terms (for example, x * y * z with no parameters) are not supported.\n\nusing JuMP, HiGHS\nimport ParametricOptInterface as POI\nmodel = Model(() -> POI.Optimizer(HiGHS.Optimizer()))\nset_silent(model)\n@variable(model, 0 <= x <= 10)\n@variable(model, p in Parameter(2))\n@objective(model, Min, p * x^2 - 3x)\noptimize!(model)\nvalue(x)  # x = 3 / 2p = 0.75\nset_parameter_value(p, 3)\noptimize!(model)\nvalue(x)  # x = 3 / 2p = 0.5","category":"section"}]
}
