<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Examples · ParametricOptInterface.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ParametricOptInterface.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../manual/">Manual</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Basic Examples</a><ul class="internal"><li><a class="tocitem" href="#MOI-example-step-by-step-usage"><span>MOI example - step by step usage</span></a></li><li><a class="tocitem" href="#JuMP-Example-step-by-step-usage"><span>JuMP Example - step by step usage</span></a></li><li><a class="tocitem" href="#JuMP-Example-Declaring-vectors-of-parameters"><span>JuMP Example - Declaring vectors of parameters</span></a></li><li><a class="tocitem" href="#JuMP-Example-Dealing-with-parametric-expressions-as-variable-bounds"><span>JuMP Example - Dealing with parametric expressions as variable bounds</span></a></li><li><a class="tocitem" href="#JuMP-Example-Non-Linear-Programming-(NLP)"><span>JuMP Example - Non Linear Programming (NLP)</span></a></li></ul></li><li><a class="tocitem" href="../benders/">Benders Quantile Regression</a></li><li><a class="tocitem" href="../markowitz/">Markowitz Efficient Frontier</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Basic Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/ParametricOptInterface.jl/blob/master/docs/src/Examples/example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Examples"><a class="docs-heading-anchor" href="#Basic-Examples">Basic Examples</a><a id="Basic-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Examples" title="Permalink"></a></h1><h2 id="MOI-example-step-by-step-usage"><a class="docs-heading-anchor" href="#MOI-example-step-by-step-usage">MOI example - step by step usage</a><a id="MOI-example-step-by-step-usage-1"></a><a class="docs-heading-anchor-permalink" href="#MOI-example-step-by-step-usage" title="Permalink"></a></h2><p>Let&#39;s write a step-by-step example of <code>POI</code> usage at the MOI level.</p><p>First, we declare a <a href="../../reference/#ParametricOptInterface.Optimizer"><code>ParametricOptInterface.Optimizer</code></a> on top of a <code>MOI</code> optimizer. In the example, we consider <code>HiGHS</code> as the underlying solver:</p><pre><code class="language- hljs">using HiGHS
using MathOptInterface
using ParametricOptInterface

const MOI = MathOptInterface
const POI = ParametricOptInterface

optimizer = POI.Optimizer(HiGHS.Optimizer())</code></pre><p>We declare the variable <code>x</code> as in a typical <code>MOI</code> model, and we add a non-negativity constraint:</p><pre><code class="language- hljs">x = MOI.add_variables(optimizer, 2)
for x_i in x
    MOI.add_constraint(optimizer, x_i, MOI.GreaterThan(0.0))
end</code></pre><p>Now, let&#39;s consider 3 <a href="../../reference/#ParametricOptInterface.Parameter"><code>ParametricOptInterface.Parameter</code></a>. Two of them, <code>y</code>, <code>z</code>, will be placed in the constraints and one, <code>w</code>, in the objective function. We&#39;ll start all three of them with a value equal to <code>0</code>:</p><pre><code class="language- hljs">w, cw = MOI.add_constrained_variable(optimizer, POI.Parameter(0))
y, cy = MOI.add_constrained_variable(optimizer, POI.Parameter(0))
z, cz = MOI.add_constrained_variable(optimizer, POI.Parameter(0))</code></pre><p>Let&#39;s add the constraints. Notice that we treat parameters and variables in the same way when building the functions that will be placed in some set to create a constraint (<code>Function-in-Set</code>):</p><pre><code class="language- hljs">cons1 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([2.0, 1.0, 3.0], [x[1], x[2], y]), 0.0)
ci1 = MOI.add_constraint(optimizer, cons1, MOI.LessThan(4.0))
cons2 = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0, 2.0, 0.5], [x[1], x[2], z]), 0.0)
ci2 = MOI.add_constraint(optimizer, cons2, MOI.LessThan(4.0))</code></pre><p>Finally, we declare and add the objective function, with its respective sense:</p><pre><code class="language- hljs">obj_func = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([4.0, 3.0, 2.0], [x[1], x[2], w]), 0.0)
MOI.set(optimizer, MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(), obj_func)
MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)</code></pre><p>Now we can optimize the model and assess its termination and primal status:</p><pre><code class="language- hljs">MOI.optimize!(optimizer)
MOI.get(optimizer, MOI.TerminationStatus())
MOI.get(optimizer, MOI.PrimalStatus())</code></pre><p>Given the optimized solution, we check that its value is, as expected, equal to <code>28/3</code>, and the solution vector <code>x</code> is <code>[4/3, 4/3]</code>:</p><pre><code class="language- hljs">isapprox(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)
isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)
isapprox(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)</code></pre><p>We can also retrieve the dual values associated to each parameter, <strong>as they are all additive</strong>:</p><pre><code class="language- hljs">MOI.get(optimizer, MOI.ConstraintDual(), cy)
MOI.get(optimizer, MOI.ConstraintDual(), cz)
MOI.get(optimizer, MOI.ConstraintDual(), cw)</code></pre><p>Notice the direct relationship in this case between the parameters&#39; duals and the associated constraints&#39; duals. The  <code>y</code> parameter, for example, only appears in the <code>cons1</code>. If we compare their duals, we can check that the dual of <code>y</code> is equal to its coefficient in <code>cons1</code> multiplied by the constraint&#39;s dual itself, as expected:</p><pre><code class="language- hljs">isapprox(MOI.get(optimizer, MOI.ConstraintDual(), cy), 3*MOI.get(optimizer, MOI.ConstraintDual(), ci1), atol = 1e-4)</code></pre><p>The same is valid for the remaining parameters. In case a parameter appears in more than one constraint, or both some constraints and in the objective function, its dual will be equal to the linear combination of the functions&#39; duals multiplied by the respective coefficients.</p><p>So far, we only added some parameters that had no influence at first in solving the model. Let&#39;s change the values associated to each parameter to assess its implications. First, we set the value of parameters <code>y</code> and <code>z</code> to <code>1.0</code>. Notice that we are changing the feasible set of the decision variables:</p><pre><code class="language- hljs">MOI.set(optimizer, POI.ParameterValue(), y, 1.0)
MOI.set(optimizer, POI.ParameterValue(), z, 1.0)</code></pre><p>However, if we check the optimized model now, there will be no changes in the objective function value or the in the optimized decision variables:</p><pre><code class="language- hljs">isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 28/3, atol = 1e-4)
isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[1]), 4/3, atol = 1e-4)
isapprox.(MOI.get(optimizer, MOI.VariablePrimal(), x[2]), 4/3, atol = 1e-4)</code></pre><p>Although we changed the parameter values, we didn&#39;t optimize the model yet. Thus, <strong>to apply the parameters&#39; changes, the model must be optimized again</strong>:</p><pre><code class="language- hljs">MOI.optimize!(optimizer)</code></pre><p>The <code>MOI.optimize!()</code> function handles the necessary updates, properly fowarding the new outer model (<code>POI</code> model) additions to the inner model (<code>MOI</code> model) which will be handled by the solver. Now we can assess the updated optimized information:</p><pre><code class="language- hljs">isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 3.0, atol = 1e-4)
MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]</code></pre><p>If we update the parameter <code>w</code>, associated to the objective function, we are simply adding a constant to it. Notice how the new objective function is precisely equal to the previous one plus the new value of <code>w</code>. In addition, as we didn&#39;t update the feasible set, the optimized decision variables remain the same.</p><pre><code class="language- hljs">MOI.set(optimizer, POI.ParameterValue(), w, 2.0)
# Once again, the model must be optimized to incorporate the changes
MOI.optimize!(optimizer)
# Only the objective function value changes
isapprox.(MOI.get(optimizer, MOI.ObjectiveValue()), 7.0, atol = 1e-4)
MOI.get.(optimizer, MOI.VariablePrimal(), x) == [0.0, 1.0]</code></pre><h2 id="JuMP-Example-step-by-step-usage"><a class="docs-heading-anchor" href="#JuMP-Example-step-by-step-usage">JuMP Example - step by step usage</a><a id="JuMP-Example-step-by-step-usage-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP-Example-step-by-step-usage" title="Permalink"></a></h2><p>Let&#39;s write a step-by-step example of <code>POI</code> usage at the JuMP level.</p><p>First, we declare a <code>Model</code> on top of a <code>Optimizer</code> of an underlying solver. In the example, we consider <code>HiGHS</code> as the underlying solver:</p><pre><code class="language- hljs">using HiGHS
using JuMP

using ParametricOptInterface
const POI = ParametricOptInterface

model = Model(() -&gt; ParametricOptInterface.Optimizer(HiGHS.Optimizer()))</code></pre><p>We declare the variable <code>x</code> as in a typical <code>JuMP</code> model:</p><pre><code class="language- hljs">@variable(model, x[i = 1:2] &gt;= 0)</code></pre><p>Now, let&#39;s consider 3 <a href="../../reference/#ParametricOptInterface.Parameter"><code>ParametricOptInterface.Parameter</code></a>. Two of them, <code>y</code>, <code>z</code>, will be placed in the constraints and one, <code>w</code>, in the objective function. We&#39;ll start all three of them with a value equal to <code>0</code>:</p><pre><code class="language- hljs">@variable(model, y in ParametricOptInterface.Parameter(0))
@variable(model, z in ParametricOptInterface.Parameter(0))
@variable(model, w in ParametricOptInterface.Parameter(0))</code></pre><p>Let&#39;s add the constraints. Notice that we treat parameters the same way we treat variables when writing the model:</p><pre><code class="language- hljs">@constraint(model, c1, 2x[1] + x[2] + 3y &lt;= 4)
@constraint(model, c2, x[1] + 2x[2] + 0.5z &lt;= 4)</code></pre><p>Finally, we declare and add the objective function, with its respective sense:</p><pre><code class="language- hljs">@objective(model, Max, 4x[1] + 3x[2] + 2w)</code></pre><p>We can optimize the model and assess its termination and primal status:</p><pre><code class="language- hljs">optimize!(model)
termination_status(model)
primal_status(model)</code></pre><p>Given the optimized solution, we check that its value is, as expected, equal to <code>28/3</code>, and the solution vector <code>x</code> is <code>[4/3, 4/3]</code>:</p><pre><code class="language- hljs">isapprox(objective_value(model), 28/3)
isapprox(value.(x), [4/3, 4/3])</code></pre><p>We can also retrieve the dual values associated to each parameter, <strong>as they are all additive</strong>:</p><pre><code class="language- hljs">MOI.get(model, POI.ParameterDual(), y)
MOI.get(model, POI.ParameterDual(), z)
MOI.get(model, POI.ParameterDual(), w)</code></pre><p>Notice the direct relationship in this case between the parameters&#39; duals and the associated constraints&#39; duals. The <code>y</code> parameter, for example, only appears in the <code>c1</code>. If we compare their duals, we can check that the dual of <code>y</code> is equal to its coefficient in <code>c1</code> multiplied by the constraint&#39;s dual itself, as expected:</p><pre><code class="language- hljs">dual_of_y = MOI.get(model, POI.ParameterDual(), y)
isapprox(dual_of_y, 3 * dual(c1))</code></pre><p>The same is valid for the remaining parameters. In case a parameter appears in more than one constraint, or both some constraints and in the objective function, its dual will be equal to the linear combination of the functions&#39; duals multiplied by the respective coefficients.</p><p>So far, we only added some parameters that had no influence at first in solving the model. Let&#39;s change the values associated to each parameter to assess its implications. First, we set the value of parameters <code>y</code> and <code>z</code> to <code>1.0</code>. Notice that we are changing the feasible set of the decision variables:</p><pre><code class="language- hljs">MOI.set(model, POI.ParameterValue(), y, 1)
MOI.set(model, POI.ParameterValue(), z, 1)
# We can also query the value in the parameters
MOI.get(model, POI.ParameterValue(), y)
MOI.get(model, POI.ParameterValue(), z)</code></pre><p>To apply the parameters&#39; changes, the model must be optimized again:</p><pre><code class="language- hljs">optimize!(model)</code></pre><p>The <code>optimize!</code> function handles the necessary updates, properly fowarding the new outer model (<code>POI</code> model) additions to the inner model (<code>MOI</code> model) which will be handled by the solver. Now we can assess the updated optimized information:</p><pre><code class="language- hljs">isapprox(objective_value(model), 3)
isapprox(value.(x), [0, 1])</code></pre><p>If we update the parameter <code>w</code>, associated to the objective function, we are simply adding a constant to it. Notice how the new objective function is precisely equal to the previous one plus the new value of <code>w</code>. In addition, as we didn&#39;t update the feasible set, the optimized decision variables remain the same.</p><pre><code class="language- hljs">MOI.set(model, POI.ParameterValue(), w, 2)
# Once again, the model must be optimized to incorporate the changes
optimize!(model)
# Only the objective function value changes
isapprox(objective_value(model), 7)
isapprox(value.(x), [0, 1])</code></pre><h2 id="JuMP-Example-Declaring-vectors-of-parameters"><a class="docs-heading-anchor" href="#JuMP-Example-Declaring-vectors-of-parameters">JuMP Example - Declaring vectors of parameters</a><a id="JuMP-Example-Declaring-vectors-of-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP-Example-Declaring-vectors-of-parameters" title="Permalink"></a></h2><p>Many times it is useful to declare a vector of parameters just like we declare a vector of variables, the JuMP syntax for variables works with parameters too:</p><pre><code class="language- hljs">using HiGHS
using JuMP
using ParametricOptInterface
const POI = ParametricOptInterface

model = Model(() -&gt; ParametricOptInterface.Optimizer(HiGHS.Optimizer()))
@variable(model, x[i = 1:3] &gt;= 0)
@variable(model, p1[i = 1:3] in ParametricOptInterface.Parameter(0))
@variable(model, p2[i = 1:3] in ParametricOptInterface.Parameter.([1, 10, 45]))
@variable(model, p3[i = 1:3] in ParametricOptInterface.Parameter.(ones(3)))</code></pre><h2 id="JuMP-Example-Dealing-with-parametric-expressions-as-variable-bounds"><a class="docs-heading-anchor" href="#JuMP-Example-Dealing-with-parametric-expressions-as-variable-bounds">JuMP Example - Dealing with parametric expressions as variable bounds</a><a id="JuMP-Example-Dealing-with-parametric-expressions-as-variable-bounds-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP-Example-Dealing-with-parametric-expressions-as-variable-bounds" title="Permalink"></a></h2><p>A very common pattern that appears when using ParametricOptInterface is to add variable and later add some expression with parameters that represent the variable bound. The following code illustrates the pattern:</p><pre><code class="language- hljs">using HiGHS
using JuMP
using ParametricOptInterface
const POI = ParametricOptInterface

model = direct_model(POI.Optimizer(HiGHS.Optimizer()))
@variable(model, x)
@variable(model, p in POI.Parameter(0.0))
@constraint(model, x &gt;= p)</code></pre><p>Since parameters are treated like variables JuMP lowers this to MathOptInterface as <code>x - p &gt;= 0</code> which is not a variable bound but a linear constraint.This means that the current representation of this problem at the solver level is:</p><p class="math-container">\[\begin{align}
    &amp; \min_{x} &amp; 0
    \\
    &amp; \;\;\text{s.t.} &amp; x &amp; \in \mathbb{R} \\
    &amp;   &amp; x - p &amp; \geq 0
\end{align}\]</p><p>This behaviour might be undesirable because it creates extra rows in your problem. Users can set the <a href="../../reference/#ParametricOptInterface.ConstraintsInterpretation"><code>ParametricOptInterface.ConstraintsInterpretation</code></a> to control how the linear constraints should be interpreted. The pattern advised for users seeking the most performance out of ParametricOptInterface should use the followig pattern:</p><pre><code class="language- hljs">using HiGHS
using JuMP
using ParametricOptInterface
const POI = ParametricOptInterface

model = direct_model(POI.Optimizer(HiGHS.Optimizer()))
@variable(model, x)
@variable(model, p in POI.Parameter(0.0))

# Indicate that all the new constraints will be valid variable bounds
MOI.set(model, POI.ConstraintsInterpretation(), POI.ONLY_BOUNDS)
@constraint(model, x &gt;= p)
# The name of this constraint was different to inform users that this is a
# variable bound.

# Indicate that all the new constraints will not be variable bounds
MOI.set(model, POI.ConstraintsInterpretation(), POI.ONLY_CONSTRAINTS)
# @constraint(model, ...)</code></pre><p>This way the mathematical representation of the problem will be:</p><p class="math-container">\[\begin{align}
    &amp; \min_{x} &amp; 0
    \\
    &amp; \;\;\text{s.t.} &amp; x &amp; \geq p
\end{align}\]</p><p>which might lead to faster solves.</p><p>Users that just want everything to work can use the default value <code>POI.ONLY_CONSTRAINTS</code> or try to use <code>POI.BOUNDS_AND_CONSTRAINTS</code> and leave it to ParametricOptInterface to interpret the constraints as bounds when applicable and linear constraints otherwise.</p><h2 id="JuMP-Example-Non-Linear-Programming-(NLP)"><a class="docs-heading-anchor" href="#JuMP-Example-Non-Linear-Programming-(NLP)">JuMP Example - Non Linear Programming (NLP)</a><a id="JuMP-Example-Non-Linear-Programming-(NLP)-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP-Example-Non-Linear-Programming-(NLP)" title="Permalink"></a></h2><p>POI currently works with NLPs when users wish to add the parameters to the non-NL constraints or objective. This means that POI works with models like this one:</p><pre><code class="language-julia hljs">@variable(model, x)
@variable(model, y)
@variable(model, z in POI.Parameter(10))
@constraint(model, x + y &gt;= z)
@NLobjective(model, Min, x^2 + y^2)</code></pre><p>but does not work with models that have parameters on the NL expressions like this one:</p><pre><code class="language-julia hljs">@variable(model, x)
@variable(model, y)
@variable(model, z in POI.Parameter(10))
@constraint(model, x + y &gt;= z)
@NLobjective(model, Min, x^2 + y^2 + z) # There is a parameter here</code></pre><p>If users with to add parameters in NL expressions we strongly recommend them to read <a href="Examples/(https:/jump.dev/JuMP.jl/stable/manual/nlp/#Create-a-nonlinear-parameter)">this section on the JuMP documentation</a></p><p>Although POI works with NLPs there are some important information for users to keep in mind. All come from the fact that POI relies on the MOI interface for problem modifications and these are not common on NLP solvers, most solvers only allow users to modify variable bounds using their official APIs. This means that if users wish to make modifications on some constraint that is not a variable bound we are not allowed to call <code>MOI.modify</code> because the function is not supported in the MOI solver interface. The work-around to this is defining a <a href="Examples/@ref"><code>POI.Optimizer</code></a> on a caching optimizer:</p><pre><code class="language-julia hljs">ipopt = Ipopt.Optimizer()
MOI.set(ipopt, MOI.RawOptimizerAttribute(&quot;print_level&quot;), 0)
cached =
    () -&gt; MOI.Bridges.full_bridge_optimizer(
        MOIU.CachingOptimizer(
            MOIU.UniversalFallback(MOIU.Model{Float64}()),
            ipopt,
        ),
        Float64,
    )
POI_cached_optimizer() = POI.Optimizer(cached())
model = Model(() -&gt; POI_cached_optimizer())
@variable(model, x)
@variable(model, y)
@variable(model, z in POI.Parameter(10))
@constraint(model, x + y &gt;= z)
@NLobjective(model, Min, x^2 + y^2)</code></pre><p>This works but keep in mind that the model has an additional layer of between the solver and the <a href="Examples/@ref"><code>POI.Optimizer</code></a>. This will make most operations slower than with the version without the caching optimizer. Keep in mind that since the official APIs of most solvers don&#39;t allow for modifications on linear constraints there should have no big difference between making a modification using POI or re-building the model from scratch.</p><p>If users wish to make modifications on variable bounds the POI interface will help you save time between solves. In this case you should use the <a href="../../reference/#ParametricOptInterface.ConstraintsInterpretation"><code>ParametricOptInterface.ConstraintsInterpretation</code></a> as we do in this example:</p><pre><code class="language-julia hljs">model = Model(() -&gt; POI.Optimizer(Ipopt.Optimizer()))
@variable(model, x)
@variable(model, z in POI.Parameter(10))
MOI.set(model, POI.ConstraintsInterpretation(), POI.ONLY_BOUNDS)
@constraint(model, x &gt;= z)
@NLobjective(model, Min, x^2)</code></pre><p>This use case should help users diminsh the time of making model modifications and re-solve the model. To increase the performance users that are familiar with <a href="https://jump.dev/JuMP.jl/stable/manual/models/#Direct-mode">JuMP direct mode</a> can also use it.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/">« Manual</a><a class="docs-footer-nextpage" href="../benders/">Benders Quantile Regression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 27 June 2022 18:38">Monday 27 June 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
